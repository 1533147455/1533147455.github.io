(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{371:function(v,_,e){"use strict";e.r(_);var o=e(45),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h4",{attrs:{id:"http-https协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-https协议"}},[v._v("#")]),v._v(" HTTP/HTTPS协议")]),v._v(" "),e("p",[e("code",[v._v("HTTPS")]),v._v("="),e("code",[v._v("HTTP")]),v._v("+"),e("code",[v._v("SSL")])]),v._v(" "),e("p",[v._v("①  对称加密：客户端和服务端用同个密钥对数据进行加密或解密\n缺点：商量密钥时可能会被窃听")]),v._v(" "),e("p",[v._v("②  非对称加密：服务端拥有一把公钥和一把私钥\n第一步：客户端向服务端索要公钥，服务端发送公钥给客户端\n第二步：客户端使用公钥进行加密，服务端用私钥进行解密\n缺点：服务端无法向客户端发送数据")]),v._v(" "),e("p",[v._v("③  "),e("code",[v._v("HTTPS")]),v._v("采用对称加密+非对称加密的机制，商量密钥阶段用非对称加密，通信阶段用对称加密\n第一步：客户端向服务端索要公钥，服务端发送公钥给客户端\n第二步：客户端定义一个随机数，用公钥加密后发送给服务端，服务端使用私钥解密得到随机数\n第三步：随机数作为对称加密的密钥使用\n缺点：假如客户端第一次索要公钥的请求就被黑客拦截，此后黑客就能一直当中间人")]),v._v(" "),e("p",[v._v("解决中间人问题的办法是数字证书机构，经过该机构认证过的公钥才是可信赖的公钥，让客户端能够确定公钥是可信赖的服务器发送过来的")]),v._v(" "),e("img",{attrs:{src:v.$withBase("/网络协议/image-20201106153032276.png"),alt:"图片加载失败"}}),v._v(" "),e("h4",{attrs:{id:"三次握手和四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手和四次挥手"}},[v._v("#")]),v._v(" 三次握手和四次挥手")]),v._v(" "),e("p",[v._v("三次握手的过程：\n第一次握手："),e("code",[v._v("A")]),v._v("向"),e("code",[v._v("B")]),v._v("发起建立连接请求："),e("code",[v._v("A")]),v._v("——>"),e("code",[v._v("B")]),v._v("\n第二次握手："),e("code",[v._v("B")]),v._v("收到"),e("code",[v._v("A")]),v._v("的请求，并且向"),e("code",[v._v("A")]),v._v("发送确认信号："),e("code",[v._v("A")]),v._v("<——"),e("code",[v._v("B")]),v._v("\n第三次握手："),e("code",[v._v("A")]),v._v("收到"),e("code",[v._v("B")]),v._v("的确认信号，并向"),e("code",[v._v("B")]),v._v("发送确认信号："),e("code",[v._v("A")]),v._v("——>"),e("code",[v._v("B")]),v._v("\n目的是为了确认双方的收发能力都正常")]),v._v(" "),e("p",[v._v("四次挥手的过程：\n第一次挥手："),e("code",[v._v("A")]),v._v("向"),e("code",[v._v("B")]),v._v("发起断开连接请求，表示"),e("code",[v._v("A")]),v._v("没有数据要发送了："),e("code",[v._v("A")]),v._v("——>"),e("code",[v._v("B")]),v._v("\n第二次挥手："),e("code",[v._v("B")]),v._v("收到"),e("code",[v._v("A")]),v._v("的请求，并且向"),e("code",[v._v("A")]),v._v("发送确认信号："),e("code",[v._v("A")]),v._v("<——"),e("code",[v._v("B")]),v._v("\n第三次挥手："),e("code",[v._v("B")]),v._v("向"),e("code",[v._v("A")]),v._v("发送信号，请求断开连接，表示"),e("code",[v._v("B")]),v._v("没有数据要发送了："),e("code",[v._v("A")]),v._v("<——"),e("code",[v._v("B")]),v._v("\n第四次挥手："),e("code",[v._v("A")]),v._v("向"),e("code",[v._v("B")]),v._v("发送确认信号，同意断开："),e("code",[v._v("A")]),v._v("——>"),e("code",[v._v("B")]),v._v("\n第二次挥手和第三次挥手不能合成一次的原因：此时"),e("code",[v._v("A")]),v._v("虽然不再发送数据了，但是还可以接收数据，"),e("code",[v._v("B")]),v._v("可能还有数据要发送给"),e("code",[v._v("A")]),v._v("\n挥手次数比握手多一次的原因：在握手过程，通信只需要处理连接。而挥手过程，通信需要处理数据"),e("code",[v._v("+")]),v._v("连接")])])}),[],!1,null,null,null);_.default=c.exports}}]);